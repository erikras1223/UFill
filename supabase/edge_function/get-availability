import { corsHeaders } from "./cors.ts";
import { createClient } from "npm:@supabase/supabase-js@2";
import { DateTime, Interval } from "https://esm.sh/luxon@3.4.0";
const supabase = createClient(Deno.env.get("SUPABASE_URL"), Deno.env.get("SUPABASE_ANON_KEY"));
const TIME_ZONE = "America/Denver"; // Mountain Standard Time
const DUMP_LOADER_SERVICE_ID = 2;
const generateTimeSlots = (start, end, interval = 60)=>{
  const slots = [];
  let current = start;
  while(current <= end){
    slots.push(current.toFormat("HH:mm"));
    current = current.plus({
      minutes: interval
    });
  }
  return slots;
};
// Convert ISO string to DateTime in UTC
const parseISOUTC = (isoStr)=>DateTime.fromISO(isoStr, {
    zone: "UTC"
  });
// Convert UTC DateTime to target timezone
const toTimeZone = (dt, zone)=>dt.setZone(zone);
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: corsHeaders
    });
  }
  try {
    const { serviceId, startDate, endDate, fetchBookings } = await req.json();
    const serviceIdInt = parseInt(serviceId, 10);
    if (!serviceIdInt || !startDate || !endDate) {
      throw new Error("Service ID, start date, and end date are required.");
    }
    const sDate = parseISOUTC(startDate);
    const eDate = parseISOUTC(endDate);
    const { data: unavailableDates, error: unavailError } = await supabase.from("unavailable_dates").select("date, service_id");
    if (unavailError) throw unavailError;
    const unavailableDatesForService = new Set(unavailableDates.filter((d)=>d.service_id === serviceIdInt || d.service_id === null).map((d)=>parseISOUTC(d.date).toISODate()));
    // Dump Loader bookings
    if (serviceIdInt === DUMP_LOADER_SERVICE_ID) {
      const { data: dumpLoaderBookings, error: dlBookingError } = await supabase.from("bookings").select("drop_off_date, pickup_date").eq("plan->>id", DUMP_LOADER_SERVICE_ID).in("status", [
        "Confirmed",
        "Delivered",
        "flagged",
        "waiting_to_be_returned"
      ]);
      if (dlBookingError) throw dlBookingError;
      dumpLoaderBookings?.forEach((booking)=>{
        const intervalDays = Interval.fromDateTimes(parseISOUTC(booking.drop_off_date), parseISOUTC(booking.pickup_date)).splitBy({
          days: 1
        }).map((i)=>i.start);
        intervalDays.forEach((day)=>unavailableDatesForService.add(day.toISODate()));
      });
    }
    // Service availability
    const { data: serviceAvailability, error: serviceAvailError } = await supabase.from("service_availability").select("*").eq("service_id", serviceIdInt);
    if (serviceAvailError) throw serviceAvailError;
    const serviceAvailMap = new Map();
    for (const d of serviceAvailability){
      serviceAvailMap.set(d.day_of_week, d);
    }
    const availabilityResult = {};
    const intervalDays = Interval.fromDateTimes(sDate, eDate).splitBy({
      days: 1
    }).map((i)=>i.start);
    const nowInMST = DateTime.now().setZone(TIME_ZONE);
    for (const day of intervalDays){
      const dayStr = day.toISODate();
      const dayInMST = toTimeZone(day, TIME_ZONE);
      const dayOfWeek = dayInMST.weekday % 7; // Luxon: 1=Mon, ..., 7=Sun
      const weeklyAvail = serviceAvailMap.get(dayOfWeek);
      if (!weeklyAvail || !weeklyAvail.is_available || unavailableDatesForService.has(dayStr)) {
        availabilityResult[dayStr] = {
          available: false,
          dropOffSlots: [],
          pickupSlots: []
        };
        continue;
      }
      let dropOffStartUTC = DateTime.fromISO(`${dayStr}T${weeklyAvail.delivery_start_time}`, {
        zone: TIME_ZONE
      }).toUTC();
      const dropOffEndUTC = DateTime.fromISO(`${dayStr}T${weeklyAvail.delivery_end_time}`, {
        zone: TIME_ZONE
      }).toUTC();
      if (dayInMST.hasSame(nowInMST, "day")) {
        const oneHourFromNowUTC = nowInMST.plus({
          hours: 1
        }).toUTC();
        if (dropOffStartUTC < oneHourFromNowUTC) dropOffStartUTC = oneHourFromNowUTC;
      }
      const dropOffSlots = dropOffEndUTC < dropOffStartUTC ? [] : generateTimeSlots(dropOffStartUTC, dropOffEndUTC);
      const pickupStartUTC = DateTime.fromISO(`${dayStr}T${weeklyAvail.pickup_start_time}`, {
        zone: TIME_ZONE
      }).toUTC();
      const pickupEndUTC = DateTime.fromISO(`${dayStr}T${weeklyAvail.pickup_end_time}`, {
        zone: TIME_ZONE
      }).toUTC();
      const pickupSlots = generateTimeSlots(pickupStartUTC, pickupEndUTC);
      availabilityResult[dayStr] = {
        available: true,
        dropOffSlots,
        pickupSlots
      };
    }
    let bookings = [];
    if (fetchBookings) {
      const { data: bookingData, error: bookingError } = await supabase.from("bookings").select("*, customers!inner(name)").gte("drop_off_date", sDate.startOf("month").toISODate()).lte("pickup_date", eDate.endOf("month").toISODate());
      if (bookingError) throw bookingError;
      bookings = bookingData;
    }
    return new Response(JSON.stringify({
      availability: availabilityResult,
      bookings
    }), {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      },
      status: 200
    });
  } catch (error) {
    console.error("Get availability error:", error);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      },
      status: 500
    });
  }
});
