import { corsHeaders } from "./cors.ts";
import { createClient } from "npm:@supabase/supabase-js@2";
import { eachDayOfInterval, formatISO, parseISO, addMinutes } from "npm:date-fns";
const supabase = createClient(Deno.env.get("SUPABASE_URL"), Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"));
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: corsHeaders
    });
  }
  try {
    const { serviceId, startDate, endDate } = await req.json();
    console.log("üî• Request payload:", {
      serviceId,
      startDate,
      endDate
    });
    if (!serviceId || !startDate || !endDate) {
      return new Response(JSON.stringify({
        error: "Missing required parameters"
      }), {
        status: 400,
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        }
      });
    }
    // Fetch service config
    const { data: service, error: serviceError } = await supabase.from("services").select("id, name").eq("id", serviceId).single();
    if (serviceError || !service) {
      console.error("‚ùå Service fetch error:", serviceError);
      return new Response(JSON.stringify({
        error: "Service not found"
      }), {
        status: 404,
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        }
      });
    }
    // Fetch service availability rules
    const { data: availRules, error: availError } = await supabase.from("service_availability").select("day_of_week, window_start_time, window_end_time, is_available, slot_interval_minutes").eq("service_id", serviceId).eq("is_available", true);
    if (availError) {
      console.error("‚ùå Service availability fetch error:", availError);
    }
    // Fetch unavailable dates (global + service-specific)
    const { data: unavailable, error: unavailError } = await supabase.from("unavailable_dates").select("date").or(`service_id.eq.${serviceId},service_id.is.null`).gte("date", startDate).lte("date", endDate);
    if (unavailError) {
      console.error("‚ùå Unavailable dates fetch error:", unavailError);
    }
    // Fetch existing bookings
    const { data: bookings, error: bookingsError } = await supabase.from("bookings").select("plan->>id as service_id, drop_off_date, drop_off_time_slot, pickup_date, pickup_time_slot").gte("drop_off_date", startDate).lte("pickup_date", endDate);
    if (bookingsError) {
      console.error("‚ùå Bookings fetch error:", bookingsError);
      return new Response(JSON.stringify({
        error: "Error fetching bookings"
      }), {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        }
      });
    }
    console.log("‚úÖ Bookings:", bookings);
    // Build availability per day
    const days = eachDayOfInterval({
      start: parseISO(startDate),
      end: parseISO(endDate)
    });
    const availability = [];
    const disabledDates = [];
    for (const day of days){
      const dayStr = formatISO(day, {
        representation: "date"
      });
      const dowJs = day.getDay(); // 0=Sun ... 6=Sat
      let available = true;
      let reason;
      let dropOffSlots = [];
      let pickupSlots = [];
      // Check if globally or service-specific unavailable
      if (unavailable?.some((u)=>u.date === dayStr)) {
        available = false;
        reason = "Marked unavailable";
        disabledDates.push(dayStr);
      } else {
        // Find availability rule for this weekday
        const rule = availRules?.find((r)=>r.day_of_week === dowJs);
        if (!rule) {
          available = false;
          reason = "No availability rule for this day";
          disabledDates.push(dayStr);
        } else if (!rule.slot_interval_minutes) {
          // No slots to generate
          available = false;
          reason = "No slots defined for this day";
          disabledDates.push(dayStr);
        } else {
          // Generate slots based on slot_interval_minutes
          let slot = parseISO(`${dayStr}T${rule.window_start_time}`);
          const end = parseISO(`${dayStr}T${rule.window_end_time}`);
          const interval = rule.slot_interval_minutes;
          while(slot <= end){
            const timeStr = formatISO(slot, {
              representation: "time"
            }).slice(0, 8);
            dropOffSlots.push(timeStr);
            pickupSlots.push(timeStr);
            slot = addMinutes(slot, interval);
          }
          // Remove already booked slots
          const dayBookings = bookings.filter((b)=>{
            console.log(`üî• b.service_id:  ${b.service_id} serviceId: ${serviceId}`);
            if (b.service_id !== String(serviceId)) return false;
            const drop = parseISO(b.drop_off_date);
            const pickup = parseISO(b.pickup_date);
            if (serviceId === 2) {
              // For service 2, block all days between drop-off and pickup
              return day >= drop && day <= pickup;
            } else {
              // For other services, only block if booking is on this date
              return dayStr === b.drop_off_date || dayStr === b.pickup_date;
            }
          });
          // Block specific booked slots based on drop_off_time_slot and pickup_time_slot
          let bookedTimes = [];
          for (const b of dayBookings){
            if (b.drop_off_time_slot && b.pickup_time_slot) {
              // Both drop-off and pickup times exist, block the window
              const start = parseISO(`${dayStr}T${b.drop_off_time_slot}`);
              const end = parseISO(`${dayStr}T${b.pickup_time_slot}`);
              let blockSlot = start;
              while(blockSlot <= end){
                const timeStr = formatISO(blockSlot, {
                  representation: "time"
                }).slice(0, 8);
                bookedTimes.push(timeStr);
                blockSlot = addMinutes(blockSlot, rule.slot_interval_minutes);
              }
              console.log(`‚õî Blocking slots for booking on ${dayStr}:`, bookedTimes);
            } else {
              // Only one time defined, block that specific slot
              if (b.drop_off_time_slot) bookedTimes.push(b.drop_off_time_slot);
              if (b.pickup_time_slot) bookedTimes.push(b.pickup_time_slot);
              console.log(`‚õî Blocking individual slots on ${dayStr}:`, bookedTimes);
            }
          }
          dropOffSlots = dropOffSlots.filter((s)=>!bookedTimes.includes(s));
          pickupSlots = pickupSlots.filter((s)=>!bookedTimes.includes(s));
          if (dropOffSlots.length === 0 && pickupSlots.length === 0) {
            available = false;
            reason = "Already booked";
            disabledDates.push(dayStr);
          }
        }
      }
      availability.push({
        date: dayStr,
        available,
        reason,
        drop_off_times: dropOffSlots.map((t)=>t.slice(0, 5)),
        pickup_times: pickupSlots.map((t)=>t.slice(0, 5)),
        usesWindows: true
      });
    }
    console.log("‚úÖ Final availability:", availability);
    return new Response(JSON.stringify({
      availability,
      disabledDates
    }), {
      headers: {
        "Content-Type": "application/json",
        ...corsHeaders
      }
    });
  } catch (err) {
    console.error("‚ùå Unexpected error:", err);
    return new Response(JSON.stringify({
      error: "Unexpected error",
      details: String(err)
    }), {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        ...corsHeaders
      }
    });
  }
});
