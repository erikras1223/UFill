import { corsHeaders } from "./cors.ts";
import { createClient } from 'npm:@supabase/supabase-js@2';
import { eachDayOfInterval, format, parse, isBefore, isSameDay, addHours, isValid, startOfDay } from 'npm:date-fns';
import { toZonedTime } from 'npm:date-fns-tz';
const supabase = createClient(Deno.env.get('SUPABASE_URL'), Deno.env.get('SUPABASE_ANON_KEY'));
const TIME_ZONE = 'America/Denver';
const DUMP_LOADER_SERVICE_ID = 2;
const generateTimeSlots = (start, end, interval = 60)=>{
  if (!isValid(start) || !isValid(end) || isBefore(end, start)) {
    return [];
  }
  const slots = [];
  let current = new Date(start);
  while(current < end){
    slots.push(format(current, 'HH:mm'));
    current = new Date(current.getTime() + interval * 60000);
  }
  return slots;
};
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: corsHeaders
    });
  }
  try {
    let body;
    try {
      body = await req.json();
    } catch (e) {
      throw new Error("Invalid JSON body provided.");
    }
    const { serviceId, startDate, endDate } = body;
    const serviceIdInt = parseInt(serviceId, 10);
    if (isNaN(serviceIdInt) || !startDate || !endDate) {
      throw new Error("Service ID, start date, and end date are required.");
    }
    const sDate = parse(startDate, 'yyyy-MM-dd', new Date());
    const eDate = parse(endDate, 'yyyy-MM-dd', new Date());
    if (!isValid(sDate) || !isValid(eDate) || isBefore(eDate, sDate)) {
      throw new Error("Invalid start or end date format.");
    }
    const { data: unavailableDates, error: unavailError } = await supabase.from('unavailable_dates').select('date, service_id');
    if (unavailError) throw unavailError;
    const unavailableDatesForService = new Set((unavailableDates || []).filter((d)=>d.service_id === serviceIdInt || d.service_id === null).map((d)=>d.date));
    if (serviceIdInt === DUMP_LOADER_SERVICE_ID) {
      const { data: dumpLoaderBookings, error: dlBookingError } = await supabase.from('bookings').select('drop_off_date, pickup_date').eq('plan->>id', DUMP_LOADER_SERVICE_ID).in('status', [
        'Confirmed',
        'Delivered',
        'flagged',
        'waiting_to_be_returned',
        'pending_payment'
      ]);
      if (dlBookingError) throw dlBookingError;
      if (dumpLoaderBookings) {
        dumpLoaderBookings.forEach((booking)=>{
          const bookingStart = parse(booking.drop_off_date, 'yyyy-MM-dd', new Date());
          const bookingEnd = parse(booking.pickup_date, 'yyyy-MM-dd', new Date());
          if (isValid(bookingStart) && isValid(bookingEnd)) {
            const bookingIntervalDays = eachDayOfInterval({
              start: bookingStart,
              end: bookingEnd
            });
            bookingIntervalDays.forEach((day)=>unavailableDatesForService.add(format(day, 'yyyy-MM-dd')));
          }
        });
      }
    }
    const { data: serviceAvailability, error: serviceAvailError } = await supabase.from('service_availability').select('*').eq('service_id', serviceIdInt);
    if (serviceAvailError) throw serviceAvailError;
    const serviceAvailMap = new Map();
    if (serviceAvailability) {
      for (const d of serviceAvailability){
        serviceAvailMap.set(d.day_of_week, d);
      }
    }
    const availabilityResult = {};
    const intervalDays = eachDayOfInterval({
      start: sDate,
      end: eDate
    });
    const nowInMST = toZonedTime(new Date(), TIME_ZONE);
    for (const day of intervalDays){
      const dayStr = format(day, 'yyyy-MM-dd');
      const dayOfWeek = day.getUTCDay();
      const weeklyAvail = serviceAvailMap.get(dayOfWeek);
      if (unavailableDatesForService.has(dayStr) || !weeklyAvail || !weeklyAvail.is_available) {
        availabilityResult[dayStr] = {
          available: false,
          dropOffSlots: [],
          pickupSlots: []
        };
        continue;
      }
      const dropOffStart = parse(`${dayStr}T${weeklyAvail.delivery_start_time || '00:00:00'}`, "yyyy-MM-dd'T'HH:mm:ss", new Date());
      const dropOffEnd = parse(`${dayStr}T${weeklyAvail.delivery_end_time || '00:00:00'}`, "yyyy-MM-dd'T'HH:mm:ss", new Date());
      let effectiveDropOffStart = dropOffStart;
      if (isSameDay(startOfDay(day), startOfDay(nowInMST))) {
        const oneHourFromNow = addHours(nowInMST, 1);
        if (isBefore(effectiveDropOffStart, oneHourFromNow)) {
          effectiveDropOffStart = oneHourFromNow;
        }
      }
      const dropOffSlots = generateTimeSlots(effectiveDropOffStart, dropOffEnd);
      const pickupStart = parse(`${dayStr}T${weeklyAvail.pickup_start_time || '00:00:00'}`, "yyyy-MM-dd'T'HH:mm:ss", new Date());
      const pickupEnd = parse(`${dayStr}T${weeklyAvail.pickup_end_time || '00:00:00'}`, "yyyy-MM-dd'T'HH:mm:ss", new Date());
      const pickupSlots = generateTimeSlots(pickupStart, pickupEnd);
      availabilityResult[dayStr] = {
        available: true,
        dropOffSlots,
        pickupSlots
      };
    }
    return new Response(JSON.stringify({
      availability: availabilityResult
    }), {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      },
      status: 200
    });
  } catch (error) {
    console.error("Get availability error:", error.message);
    return new Response(JSON.stringify({
      error: `An unexpected error occurred: ${error.message}`
    }), {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      },
      status: 500
    });
  }
});
