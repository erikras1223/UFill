import { corsHeaders } from "./cors.ts";
import { Stripe } from "npm:stripe@15.8.0";
import { createClient } from "npm:@supabase/supabase-js@2";
const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY"), {
  apiVersion: "2024-06-20"
});
const supabase = createClient(Deno.env.get("SUPABASE_URL"), Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"));
// --- Helper ---
const handleCheckoutCompleted = async (session)=>{
  const bookingId = session?.metadata?.booking_id || session?.client_reference_id;
  const checkoutSessionId = session?.id;
  const paymentIntentId = session?.payment_intent;
  const stripeCustomerId = session?.customer;
  if (!bookingId || !checkoutSessionId) {
    console.error(`Webhook: Missing booking_id or session_id. booking_id=${bookingId} session_id=${checkoutSessionId}`);
    return;
  }
  try {
    // Get charge id if possible
    let chargeId = null;
    if (typeof paymentIntentId === "string") {
      const pi = await stripe.paymentIntents.retrieve(paymentIntentId, {
        expand: [
          "latest_charge"
        ]
      });
      if (pi?.latest_charge) {
        chargeId = typeof pi.latest_charge === "string" ? pi.latest_charge : pi.latest_charge.id;
      }
    }
    // Link Stripe Customer â†’ our customers row (via booking)
    if (stripeCustomerId) {
      const { data: bookingRow, error: bookingErr } = await supabase.from("bookings").select("customer_id").eq("id", bookingId).single();
      if (!bookingErr && bookingRow?.customer_id) {
        await supabase.from("customers").update({
          stripe_customer_id: String(stripeCustomerId)
        }).eq("id", bookingRow.customer_id);
      }
    }
    // Set booking status
    const { error: updateBookingErr } = await supabase.from("bookings").update({
      status: "awaiting_processing"
    }).eq("id", bookingId);
    if (updateBookingErr) {
      console.error(`Webhook: Failed to update booking ${bookingId}`, updateBookingErr);
    }
    // Upsert Stripe IDs
    const { error: upsertErr } = await supabase.from("stripe_payment_info").upsert({
      booking_id: bookingId,
      stripe_checkout_session_id: checkoutSessionId,
      stripe_customer_id: stripeCustomerId ? String(stripeCustomerId) : null,
      stripe_payment_intent_id: paymentIntentId ? String(paymentIntentId) : null,
      stripe_charge_id: chargeId
    }, {
      onConflict: "booking_id"
    });
    if (upsertErr) {
      console.error(`Webhook: Failed to upsert stripe_payment_info for booking ${bookingId}`, upsertErr);
    } else {
      console.log(`Webhook: Stored Stripe IDs for booking ${bookingId} (session ${checkoutSessionId})`);
    }
  } catch (err) {
    console.error(`Webhook: Error processing checkout.session.completed for booking ${bookingId}:`, err);
  }
};
// --- Handler ---
Deno.serve(async (req)=>{
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", {
      status: 405
    });
  }
  const signature = req.headers.get("Stripe-Signature");
  if (!signature) {
    return new Response("Missing Stripe-Signature header", {
      status: 400
    });
  }
  let body;
  try {
    body = await req.text(); // RAW body required
  } catch  {
    return new Response("Invalid body", {
      status: 400
    });
  }
  let event;
  try {
    event = await stripe.webhooks.constructEventAsync(body, signature, Deno.env.get("STRIPE_WEBHOOK_SIGNING_SECRET"));
  } catch (err) {
    console.error("Signature verification failed:", err?.message);
    return new Response("Bad signature", {
      status: 400
    });
  }
  try {
    switch(event.type){
      case "checkout.session.completed":
      case "checkout.session.async_payment_succeeded":
        await handleCheckoutCompleted(event.data.object);
        break;
      default:
        break;
    }
  } catch (err) {
    console.error("Webhook handler error:", err);
  // still return 200 to prevent retries unless it's a real failure
  }
  return new Response(JSON.stringify({
    received: true
  }), {
    status: 200,
    headers: {
      ...corsHeaders,
      "Content-Type": "application/json"
    }
  });
});
